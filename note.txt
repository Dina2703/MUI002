__________ MUIv5.4.0 and v4 versions, pick one to work______________

https://mui.com/customization/default-theme/     //use this default theme objects to override the themes.

* variantMapping allows us the same components work where component allows us to choose the default DOM element that you component  gets rendered on top of.  VarinatMapping allow us to do that for evey single variant within your typography. Example:
if typography varinat="h1", you can add props 
variantMapping={{
  h1: 'span',
}}
now all the 'h1'- s turned to 'span' element(can see via dev tool), but looks the same as 'h1' on the VIEW/browser user sees as 'h1'.

------------ Css MUI typography--------------
import {makeStyles} from '@material-ui/core/styles';
*  fisrt step define the custom style
const useStyles = makeStyles({
gutterBottom: {                
  marginBottom: '0.6em';
}
})
*  inside the just before the return() inside the component call the useStyles() and store its value to a const, like:
const classes = useStyles();
*   second apply the custom style to the component via 'classes' object.
<Typography className={classes.gutterBottom} variant='h2'>
Hello
</Typography>

<Button> the      disableElevation prop to put away the bottom shadow from the button.

____________MUI Icons_____________
 npm install @material-ui/icons   // firts install the icons package
 then import  the right Icon you need from the package, and ute it as a component.
 You can put it inside the <Button> component using endIcon or startIcon props.

 _________________makeStyles Hook MUI_____________
 makeStyles() function and using that function we can create CSS classes and rules using JS objects, and this function returns to us a react hook which we can then use inside our component to acces those styles and classes and we can apply them to any elements in our React component.

 IMPORTANT!!
 import { makeStyles } from "@material-ui/core";  //you need to distructur it like so, because it's not a component, it s a FUNCTION.
then we have to use this function outside of our component to begin with. We gonna store the result of this function in a const 'useStyles'. And inside the makeStyles() function we passing an object our different css classes and rules. Each property inside this object is gonna be a css class( like: btn), and the object will specify the different  properties of this button, the properties should be in camel case.
Example: 
const useStyles = makeStyles({
  btn: {
    fontSize: 60,
  },
});

then, fire the hook inside the Component and and store the value into const 'classes', and this hooke returns to us an object with all of the different classes on it, so we can access them.
like:  className={classes.btn} inside the <Button> 
__________hover state______________
How to apply the 'hover' state to the class.
inside the useStyles() pass to any class you want to have hover state.
    "&:hover": {
      backgroundColor: "blue",
    },

------------------THEME in MUI---------------
Theme is in MUI is a bit like a big object with all of these different properties and values which specify things like what what color should be the primary and secondary, all CSS things.

We need to create our custom Theme in the App.js, so it can wrap all our components, in that way our entire application can access this Theme.
* The first step 
import { createTheme, ThemeProvider } from "@material-ui/core";   /at the top of  the App.js

createTheme() this function helps to create the custom theme object.
ThemeProvider component  is gonna wrap our application and pass them the custom theme that we created with createTheme() function.

* the second step
createTheme({}) this function takes in an object as an argument. And this object represents the theme we want to create. WE have to pick and choose which property we want to override( look at the default theme page in MUI)
exapmle, if we want to override the primary color, we need to define property 'palette' -> 'primary' -> 'main', how it shown in the theme object, and we can pass any HEX code we want for the color, like:
const theme = createTheme({
  palette: {
    primary: {
      main: "#fff",
    },
  },
});
* third step 
We need to provide the application with this Theme(we jsut created).
return(
   <ThemeProvider theme={theme}>
   children/some Components
   <ThemeProvider>
);

__________Colors objects from MUI-------------
Another way of creating custom Theme is by using the Colors objects from MUI, like: 
  secondary: purple,   / just like that, pass it to the 'palette' object. purple is the object in MUI, not the single color, which has different properties like 'light', 'dark', other.


  ---------------Custom Font------------
  we can use our own custom font, instead of 'roboto'(which is the main theme for font) in every component. For that we can use 'Google Fonts'. pick the right one, select the different font sized (by clicking the '+ Select this style'), press 'import' and grab the @import line, which imports the font into our project.
  You can use <link> to add it into our HTML file. or @import to add it into index.css file.
  * the second step is add some styles.
  in App.js inside the createTheme({}) pass a 'typography' property, to this pass the props with values, like 

    typography: {
    fontFamily: "Quicksand",
    fontWeightLight: 400,
    fontWeightRegular: 500,
    fontWeightMedium: 600,
    fontWeightBold: 700,
  },
//all these fontSizes we picked from the google-font.

--------Text Field--------------
import <TextField> from MUI,
then create a plain <form> tag, and you can give it the 
* 'noValidate'  -  props, which says to the browser, don't use the built-in validation messages, we gonna hanlde it ourselves. 
* 'autoComplete='off''   - props which turns off the ability to autocomplete anything when you started to type.
So inside the <form> put <TextField />
* 'label' props you can use inside the <TextField />.
* 'variant' props (outlined,filled, standard )
* fullwidth  props to make the full 100% width for the TextField
* required props  gives a small '*' .
we can add CSS class to this via makeStyles() function and useStyles() hook
* multyline      /works with the rows prop(below)
* rows={ 4 }     / that means 4 rows of text inside the text field.

----------To track the user input // TextField and State----------------
to track what a user types into this TextField, and store them in some kinda state.
we can add:
onChange event, which fires, 
* first  create a bit of state to store the data.

const handleSubmit = (e) => {
e.preventDefault();   //this prevens from refreshing the page, we don't want that.
  if (title && details) {        //thanks to this line, if one of te these two fields is empty, the form doesn't let you submit the form. Kind validation thing
  console.log(title, details);
  }
};
-----------How to add an error states to the <TextField />
error={true}     //pass it into <TextField /> as props. Of it's true, it shows some kinda error feedback, like red border and label. 
 * to make the error dynamic, 
* first define some state for them, for two TextFieldfa-spin  
const [titleError, setTitleError] = useState(false);   / we need to set them to false, to begin with.
const [detailsError, setDetailsError] = useState(false);

then, pass them to <TextField />, like  
'error={titleError}'
then, inside the handleSubmit()
we need to add these setTitleError & setDetailsError hooks, to set the state to false after the each submitted/ submit button pressed, then we do the checks and only set them to true if they're not valid.  Otherwise, after first the fail(if you tried to submit the empty form, you get error), the error messages(red border and label)  don't go away.
  const handleSubmit = (e) => {
    e.preventDefault();
    setDetailsError(false);
    setTitleError(false);

    ---------Radio & RadioGroup-----------
    <RadioGroup>  allows us select only one at a time from the given  <Radio> options.
    exapmle: 
<RadioGroup>
  <Radio value="hello" />
  <Radio value="goodbye" />
</RadioGroup>

------------Form Control Label * THE BEST WAY FOR RADIO BUTTONS-----------
Form Control Label gives us a way to create a lable , which kind of wraps around the control the <Radio> button.
for that use <FormControlLabel>, like:
<RadioGroup>
<FormControlLabel value="money" control={<Radio /> label="Money" />
<FormControlLabel value="work" control={<Radio />} label="Work" />
</RadioGroup>
===============To Store a value selected from the Radio==========
we need some state for that.
To set the default value for <Radio>, we need to show it in the state initial value, as   const [category, setCategory] = useState("todos"); then, inside the opening RadioGroup tag put ---> <RadioGroup value={category}>, which will show the initail value for 'categoty', that we set inside the state. 
the way to update that 'category'  value. whenever a user selects the different value. We can do it by using the onChange(), which takes the event object(e), like:
<RadioGroup
value={category}
onChange={(e) => setCategory(e.target.value)}
>

-------------  FormLabel, FormControl -------------
they are like A WRAPPERS fro the different section, certain control area of the form.
 <FormControl> to wrap all sections of the Form
 <FormLabel> to wrap the form Label.

 -------------Using JSON Server----------------
 with Local state in our components means that every time we refresh the page it's going to reset our data to that initial state from our component.
 Instead what we can do is work with a JSON file to store our data, and using JSON server to interact with it.
 So JSON server basically wraps a json file with REST API  endpoint so that we can fetch data inside that JSON file using a get requset or add data to it using a POST request etc. 
 So it's really good for testing and propotyping so that we don't have to worry about a server side logic or databases.
 * the first step is creating a JSON file, where we will store our data. Structure should be: the root folder --> create 'data' folder inside it 'db.json'.
How JSON Server works is that it looks at this json file and any top level property it sees as a resource. So in our case we have one top level property called 'notes', and it sees that as a particular resource in our JSON file, and it (JSON server) sets up endpoint to interact with that resource, so I can get all of the notes or could add to the 'notes' for example. In our case we have a three individual notes objects  inside the top level 'notes' object.The  each note has several properties, like 'title', 'details', 'category', 'id' (unique 'id' gonna be used by React when we cycle through this data later on and output it to the screen).
* The next step is insalling JSON server onto your computer for this to work.
----npm install -g json-server   //to install Globally. if you have it on your computer.then run
we need a path to the JSON file from where we are right  , then specify the what port to run these endpoints on , then press 'enter' (it was GET request)
----json-server --watch data/db.json --post 8000.
http://localhost:8000/notes  to see you 'notes' json data got to this URL.
------get the json-data  and place them into our componet-----------
*   The first step, retrieve all of the data from the db.json and list them into 'Notes' component, so we can see them on the page.
The way we gonna do this is by using the useEffect() hook in this 'Notes' component.
useEffect() is gonna run a function for us when this component first loads and inside that function we can then you a fetch request to grab the data using the endpoint that JSON Server provides us with. To this useEffect() we gonna pass as the first argument a function to run, and the second argument an array [] for dependencies, An empty [] means tun run the passed function only once, when the component loaded first time.  
IMPORTANT!!!!!The fetch() is async, so it takes some time to do.
inside the fetch() pass the endpoint, like:
 ------fetch("http://localhost:8000/notes"), it returns to us a promise, then we tack on a then() method which fires a finction, when fetch() gives us a data. And this .then() function gets access to this responce ofject(what comes from the fetch()).
 This responce(res) object doen't contain the data directly and what we need to do is pass it into some kind of form we can work with and to do that we say 'res.json()', that is a function, which takes the json and passes it into a JS object/ or JS array in our case , because it's an array of objects we're getting back.
 ----.then((res) => res.json())
  This is async in itself and we return it right here. So we can tack on another .then()  method. In this time we get access to the actual  data(an array of objects).
  * the next we want to store that data in some kind of state.
  const [notes, setNotes] = useState([]);  // first create a state, and set the initial value to an empty array, then pass our data to it, like;
   >GET request<
useEffect(() => {
fetch("http://localhost:8000/notes")
  .then((res) => res.json())
  .then((data) => setNotes(data));   // passing the data to useState()
}, []);
* now we have our data inside the component, now we need to output it to the browser, for that we need to cycle throught it. The way we do that in React is by using the map(). and return some template to display. like: 
return (
<div>
  {notes.map((note) => (
    <p key={note.id}>{note.title}</p>
  ))}
</div>
);
Now on the browser, you can see the output of some data on our page.
   >POST request<
To add data to JSON file, every time a user submits the form. 
We gonna do that inside the Create.js,  inside the 'if (title && details) {here}'
* first fetch() to the same endpoint, and this time add a second argument, which is an object. And this object is gonna have several properties inside it,
the first one is method: "POST" , this tells fetch that we're making a POSt request to add data, the second one gonna be the 'header' property, which tells what type of content is going to be sent, like  
--headers: { "Content-type": "application/json" },  
the third we have the 'body', where we send the actual json data,  in our case we want to send 'title', 'category', and 'details'. first of all we need to stringify them into JSOn, we can't send a JS object. When we're transferring data using fetch it needs to be in JSON format. so we say JSON.stringify and pass in an object we wannna stringify, like: 
body: JSON.stringify({
  title,
  details,
  category,
}),
JSON.stringify takes all the passed values(title,details,category,), adds them to this object stringifies that then we're can send it in the POST request.
When JSON Server does that , this is gonna to add this new value the 'notes array, inside our db.json file. And JSON server auto adds unique id prooperty to our new note object.

* the next step, because fetch() is async, we can tack on, and redirect the user to 'Notes' page. For that we can use useHistory() hook built in REACT.
----------useHistory()----------
import { useHistory } from "react-router-dom";       /first import 
 const history = useHistory();                        /invoke that from inside the Component, then use this 'history' object, which has push() method, which allows us to push onto a new route, that we pass inside the('/'), like;
 .then(() => history.push("/"));