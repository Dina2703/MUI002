__________ MUIv5.4.0 and v4 versions, pick one to work______________

https://mui.com/customization/default-theme/     //use this default theme objects to override the themes.

* variantMapping allows us the same components work where component allows us to choose the default DOM element that you component  gets rendered on top of.  VarinatMapping allow us to do that for evey single variant within your typography. Example:
if typography varinat="h1", you can add props 
variantMapping={{
  h1: 'span',
}}
now all the 'h1'- s turned to 'span' element(can see via dev tool), but looks the same as 'h1' on the VIEW/browser user sees as 'h1'.

------------ Css MUI typography--------------
import {makeStyles} from '@material-ui/core/styles';
*  fisrt step define the custom style
const useStyles = makeStyles({
gutterBottom: {                
  marginBottom: '0.6em';
}
})
*  inside the just before the return() inside the component call the useStyles() and store its value to a const, like:
const classes = useStyles();
*   second apply the custom style to the component via 'classes' object.
<Typography className={classes.gutterBottom} variant='h2'>
Hello
</Typography>

<Button> the      disableElevation prop to put away the bottom shadow from the button.

____________MUI Icons_____________
 npm install @material-ui/icons   // firts install the icons package
 then import  the right Icon you need from the package, and ute it as a component.
 You can put it inside the <Button> component using endIcon or startIcon props.

 _________________makeStyles Hook MUI_____________
 makeStyles() function and using that function we can create CSS classes and rules using JS objects, and this function returns to us a react hook which we can then use inside our component to acces those styles and classes and we can apply them to any elements in our React component.

 IMPORTANT!!
 import { makeStyles } from "@material-ui/core";  //you need to distructur it like so, because it's not a component, it s a FUNCTION.
then we have to use this function outside of our component to begin with. We gonna store the result of this function in a const 'useStyles'. And inside the makeStyles() function we passing an object our different css classes and rules. Each property inside this object is gonna be a css class( like: btn), and the object will specify the different  properties of this button, the properties should be in camel case.
Example: 
const useStyles = makeStyles({
  btn: {
    fontSize: 60,
  },
});

then, fire the hook inside the Component and and store the value into const 'classes', and this hooke returns to us an object with all of the different classes on it, so we can access them.
like:  className={classes.btn} inside the <Button> 
__________hover state______________
How to apply the 'hover' state to the class.
inside the useStyles() pass to any class you want to have hover state.
    "&:hover": {
      backgroundColor: "blue",
    },

------------------THEME in MUI---------------
Theme is in MUI is a bit like a big object with all of these different properties and values which specify things like what what color should be the primary and secondary, all CSS things.

We need to create our custom Theme in the App.js, so it can wrap all our components, in that way our entire application can access this Theme.
* The first step 
import { createTheme, ThemeProvider } from "@material-ui/core";   /at the top of  the App.js

createTheme() this function helps to create the custom theme object.
ThemeProvider component  is gonna wrap our application and pass them the custom theme that we created with createTheme() function.

* the second step
createTheme({}) this function takes in an object as an argument. And this object represents the theme we want to create. WE have to pick and choose which property we want to override( look at the default theme page in MUI)
exapmle, if we want to override the primary color, we need to define property 'palette' -> 'primary' -> 'main', how it shown in the theme object, and we can pass any HEX code we want for the color, like:
const theme = createTheme({
  palette: {
    primary: {
      main: "#fff",
    },
  },
});
* third step 
We need to provide the application with this Theme(we jsut created).
return(
   <ThemeProvider theme={theme}>
   children/some Components
   <ThemeProvider>
);

__________Colors objects from MUI-------------
Another way of creating custom Theme is by using the Colors objects from MUI, like: 
  secondary: purple,   / just like that, pass it to the 'palette' object. purple is the object in MUI, not the single color, which has different properties like 'light', 'dark', other.


  ---------------Custom Font------------
  we can use our own custom font, instead of 'roboto'(which is the main theme for font) in every component. For that we can use 'Google Fonts'. pick the right one, select the different font sized (by clicking the '+ Select this style'), press 'import' and grab the @import line, which imports the font into our project.
  You can use <link> to add it into our HTML file. or @import to add it into index.css file.
  * the second step is add some styles.
  in App.js inside the createTheme({}) pass a 'typography' property, to this pass the props with values, like 

    typography: {
    fontFamily: "Quicksand",
    fontWeightLight: 400,
    fontWeightRegular: 500,
    fontWeightMedium: 600,
    fontWeightBold: 700,
  },
//all these fontSizes we picked from the google-font.

--------Text Field--------------
import <TextField> from MUI,
then create a plain <form> tag, and you can give it the 
* 'noValidate'  -  props, which says to the browser, don't use the built-in validation messages, we gonna hanlde it ourselves. 
* 'autoComplete='off''   - props which turns off the ability to autocomplete anything when you started to type.
So inside the <form> put <TextField />
* 'label' props you can use inside the <TextField />.
* 'variant' props (outlined,filled, standard )
* fullwidth  props to make the full 100% width for the TextField
* required props  gives a small '*' .
we can add CSS class to this via makeStyles() function and useStyles() hook
* multyline      /works with the rows prop(below)
* rows={ 4 }     / that means 4 rows of text inside the text field.

----------To track the user input // TextField and State----------------
to track what a user types into this TextField, and store them in some kinda state.
we can add:
onChange event, which fires, 
* first  create a bit of state to store the data.

const handleSubmit = (e) => {
e.preventDefault();   //this prevens from refreshing the page, we don't want that.
  if (title && details) {        //thanks to this line, if one of te these two fields is empty, the form doesn't let you submit the form. Kind validation thing
  console.log(title, details);
  }
};
-----------How to add an error states to the <TextField />
error={true}     //pass it into <TextField /> as props. Of it's true, it shows some kinda error feedback, like red border and label. 
 * to make the error dynamic, 
* first define some state for them, for two TextFieldfa-spin  
const [titleError, setTitleError] = useState(false);   / we need to set them to false, to begin with.
const [detailsError, setDetailsError] = useState(false);

then, pass them to <TextField />, like  
'error={titleError}'
then, inside the handleSubmit()
we need to add these setTitleError & setDetailsError hooks, to set the state to false after the each submitted/ submit button pressed, then we do the checks and only set them to true if they're not valid.  Otherwise, after first the fail(if you tried to submit the empty form, you get error), the error messages(red border and label)  don't go away.
  const handleSubmit = (e) => {
    e.preventDefault();
    setDetailsError(false);
    setTitleError(false);